// app/api/customer/automation-status/route.js
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs';
import { 
  getCustomerByClerkId, 
  getDbClient 
} from '../../../../lib/database';

export async function GET() {
  try {
    const user = await currentUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get customer from database (using your existing structure)
    const customer = await getCustomerByClerkId(user.id);
    
    if (!customer) {
      return NextResponse.json({ error: 'Customer not found' }, { status: 404 });
    }

    console.log('üîß Getting automation status for customer:', customer.business_name);

    const client = await getDbClient().connect();
    try {
      // Get email settings and automation status
      const settingsQuery = 'SELECT * FROM email_settings WHERE customer_id = $1';
      const settingsResult = await client.query(settingsQuery, [customer.id]);
      const settings = settingsResult.rows[0];

      // Check Gmail connection status (you might want to call your existing Gmail status API)
      let gmailConnected = false;
      try {
        // You could integrate with your existing Gmail status check here
        // For now, we'll check if they have Gmail-related settings
        gmailConnected = !!(settings?.setup_method && settings.setup_method !== 'intellihub');
      } catch (error) {
        console.log('Gmail status check failed:', error.message);
      }

      // Get recent monitoring statistics
      let monitoringStats = { emailsToday: 0, responsesToday: 0, lastCheck: null };
      try {
        const statsQuery = `
          SELECT 
            COALESCE(emails_processed_today, 0) as emails_today,
            COALESCE(ai_responses_sent_today, 0) as responses_today,
            last_monitored
          FROM email_settings 
          WHERE customer_id = $1
        `;
        const statsResult = await client.query(statsQuery, [customer.id]);
        if (statsResult.rows.length > 0) {
          const stats = statsResult.rows[0];
          monitoringStats = {
            emailsToday: parseInt(stats.emails_today) || 0,
            responsesToday: parseInt(stats.responses_today) || 0,
            lastCheck: stats.last_monitored
          };
        }
      } catch (error) {
        console.log('Stats query failed (columns might not exist yet):', error.message);
      }

      // Build automation status response
      const automationStatus = {
        gmailConnection: {
          connected: gmailConnected,
          email: settings?.email_address || null,
          status: gmailConnected ? 'active' : 'not_connected'
        },
        
        aiSettings: {
          enabled: settings?.auto_response_enabled !== false,
          tone: settings?.tone || 'professional',
          model: settings?.ai_model || 'gpt-4o-mini',
          temperature: settings?.ai_temperature || 0.7,
          hotLeadAlerts: settings?.alert_hot_leads !== false
        },
        
        emailFiltering: {
          autoArchiveSpam: settings?.auto_archive_spam !== false,
          blockMassEmails: settings?.block_mass_emails !== false,
          personalOnly: settings?.personal_only === true,
          skipAutoGenerated: settings?.skip_auto_generated !== false
        },
        
        responseRules: {
          businessHoursOnly: settings?.business_hours_only !== false,
          urgentPriority: settings?.urgent_priority !== false,
          requireApproval: settings?.require_approval === true,
          autoResponseEnabled: settings?.auto_response_enabled !== false
        },
        
        monitoring: {
          enabled: settings?.monitoring_enabled !== false,
          autoRefreshInterval: settings?.auto_refresh_interval || 30,
          lastCheck: monitoringStats.lastCheck,
          emailsToday: monitoringStats.emailsToday,
          responsesToday: monitoringStats.responsesToday
        },
        
        systemHealth: {
          databaseConnected: true,
          settingsConfigured: !!settings,
          gmailIntegration: gmailConnected,
          aiConfigured: !!(settings?.tone && settings?.expertise)
        }
      };

      return NextResponse.json({
        success: true,
        automation: automationStatus,
        customer: {
          id: customer.id,
          business_name: customer.business_name,
          email: customer.email
        }
      });

    } finally {
      client.release();
    }

  } catch (error) {
    console.error('‚ùå Error getting automation status:', error);
    return NextResponse.json({ 
      error: 'Failed to get automation status',
      details: error.message 
    }, { status: 500 });
  }
}

export async function POST(request) {
  try {
    const user = await currentUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const customer = await getCustomerByClerkId(user.id);
    
    if (!customer) {
      return NextResponse.json({ error: 'Customer not found' }, { status: 404 });
    }

    const { action, data } = await request.json();
    console.log(`üîß Automation action: ${action} for customer:`, customer.business_name);

    const client = await getDbClient().connect();
    try {
      switch (action) {
        case 'toggle-monitoring':
          const toggleQuery = `
            UPDATE email_settings 
            SET monitoring_enabled = NOT COALESCE(monitoring_enabled, true),
                updated_at = CURRENT_TIMESTAMP
            WHERE customer_id = $1
            RETURNING monitoring_enabled
          `;
          const toggleResult = await client.query(toggleQuery, [customer.id]);
          const newStatus = toggleResult.rows[0]?.monitoring_enabled || false;
          
          return NextResponse.json({
            success: true,
            message: `Monitoring ${newStatus ? 'enabled' : 'disabled'}`,
            monitoring_enabled: newStatus
          });

        case 'update-refresh-interval':
          const interval = parseInt(data.interval) || 30;
          if (interval < 10 || interval > 300) {
            return NextResponse.json({ error: 'Interval must be between 10 and 300 seconds' }, { status: 400 });
          }
          
          const intervalQuery = `
            UPDATE email_settings 
            SET auto_refresh_interval = $1,
                updated_at = CURRENT_TIMESTAMP
            WHERE customer_id = $2
          `;
          await client.query(intervalQuery, [interval, customer.id]);
          
          return NextResponse.json({
            success: true,
            message: `Refresh interval updated to ${interval} seconds`,
            auto_refresh_interval: interval
          });

        case 'reset-daily-stats':
          const resetQuery = `
            UPDATE email_settings 
            SET emails_processed_today = 0,
                ai_responses_sent_today = 0,
                last_stats_reset = CURRENT_DATE
            WHERE customer_id = $1
          `;
          await client.query(resetQuery, [customer.id]);
          
          return NextResponse.json({
            success: true,
            message: 'Daily statistics reset successfully'
          });

        case 'test-filters':
          // This would test email filtering rules
          return NextResponse.json({
            success: true,
            message: 'Filter testing completed',
            results: [
              { email: 'newsletter@company.com', filtered: true, reason: 'Mass email detected' },
              { email: 'john@gmail.com', filtered: false, reason: 'Personal email allowed' }
            ]
          });

        default:
          return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
      }

    } finally {
      client.release();
    }

  } catch (error) {
    console.error('‚ùå Error processing automation action:', error);
    return NextResponse.json({ 
      error: 'Failed to process automation action',
      details: error.message 
    }, { status: 500 });
  }
}
