// lib/email-filtering.js
// Email filtering service that applies business rules and filtering settings
import { query } from './database';

/**
 * Helper function to safely parse JSON
 */
function tryParseJSON(jsonString, defaultValue = []) {
  try {
    if (!jsonString) return defaultValue;
    if (typeof jsonString === 'object') return jsonString; // Already parsed
    if (Array.isArray(jsonString)) return jsonString; // Already an array
    return JSON.parse(jsonString);
  } catch (e) {
    console.error('JSON parse error:', e);
    return defaultValue;
  }
}

/**
 * Check if an email should be filtered based on business rules and settings
 * @param {Object} emailData - Email data to check
 * @param {Object} filterSettings - Customer's filter settings
 * @returns {Object} - Filter result with reason and action
 */
export async function checkEmailFilter(emailData, filterSettings) {
  const { from, subject, body, isAutoGenerated, isMassEmail } = emailData;
  
  // Extract email address from "Name <email@domain.com>" format
  const emailMatch = from.match(/<(.+?)>/) || from.match(/([^\s<>]+@[^\s<>]+)/);
  const senderEmail = emailMatch ? emailMatch[1] || emailMatch[0] : from;
  const senderDomain = senderEmail.split('@')[1] || '';
  
  console.log('ðŸ” Checking email filter for:', senderEmail);
  
  // Parse JSON fields safely
  const whitelist = tryParseJSON(filterSettings.whitelist_emails, []);
  const blacklist = tryParseJSON(filterSettings.blacklist_emails, []);
  const keywords = tryParseJSON(filterSettings.priority_keywords, []);
  
  // Priority 1: Check whitelist (always allow)
  if (whitelist && whitelist.length > 0) {
    for (const whitelistItem of whitelist) {
      if (isMatchingRule(senderEmail, senderDomain, whitelistItem)) {
        console.log('âœ… Email whitelisted:', whitelistItem);
        return { 
          shouldFilter: false, 
          reason: 'whitelisted',
          matchedRule: whitelistItem 
        };
      }
    }
  }
  
  // Priority 2: Check blacklist (always block)
  if (blacklist && blacklist.length > 0) {
    for (const blacklistItem of blacklist) {
      if (isMatchingRule(senderEmail, senderDomain, blacklistItem)) {
        console.log('ðŸš« Email blacklisted:', blacklistItem);
        return { 
          shouldFilter: true, 
          reason: 'blacklisted',
          filterType: 'blacklist',
          matchedRule: blacklistItem 
        };
      }
    }
  }
  
  // Priority 3: Check spam indicators
  if (filterSettings.auto_archive_spam !== false) {
    const spamIndicators = checkSpamIndicators(from, subject, body);
    if (spamIndicators.isSpam) {
      console.log('ðŸ—‘ï¸ Email identified as spam:', spamIndicators.reason);
      return { 
        shouldFilter: true, 
        reason: spamIndicators.reason,
        filterType: 'spam',
        confidence: spamIndicators.confidence 
      };
    }
  }
  
  // Priority 4: Check mass email
  if (filterSettings.block_mass_emails !== false && isMassEmail) {
    console.log('ðŸ“§ Mass email filtered');
    return { 
      shouldFilter: true, 
      reason: 'mass email',
      filterType: 'mass_email' 
    };
  }
  
  // Priority 5: Check auto-generated
  if (filterSettings.skip_auto_generated !== false && isAutoGenerated) {
    console.log('ðŸ¤– Auto-generated email filtered');
    return { 
      shouldFilter: true, 
      reason: 'auto-generated',
      filterType: 'auto_generated' 
    };
  }
  
  // Priority 6: Personal only mode
  if (filterSettings.personal_only === true) {
    const personalIndicators = checkPersonalIndicators(from, subject, body);
    if (!personalIndicators.isPersonal) {
      console.log('ðŸ‘¥ Non-personal email filtered');
      return { 
        shouldFilter: true, 
        reason: 'not personal',
        filterType: 'not_personal',
        confidence: personalIndicators.confidence 
      };
    }
  }
  
  // Priority 7: Check priority keywords (mark as priority, don't filter)
  if (keywords && keywords.length > 0) {
    const contentToCheck = `${subject} ${body}`.toLowerCase();
    
    for (const keyword of keywords) {
      if (contentToCheck.includes(keyword.toLowerCase())) {
        console.log('â­ Priority keyword matched:', keyword);
        return { 
          shouldFilter: false, 
          isPriority: true,
          reason: 'priority keyword',
          matchedKeyword: keyword 
        };
      }
    }
  }
  
  // Email passes all filters
  return { 
    shouldFilter: false, 
    reason: 'passed all filters' 
  };
}

/**
 * Check if email/domain matches a rule
 */
function isMatchingRule(email, domain, rule) {
  if (!rule) return false;
  
  const ruleLower = rule.toLowerCase().trim();
  const emailLower = email.toLowerCase().trim();
  const domainLower = domain.toLowerCase().trim();
  
  // Check if it's a domain rule (starts with @ or is just a domain)
  if (ruleLower.startsWith('@')) {
    return domainLower === ruleLower.substring(1);
  } else if (!ruleLower.includes('@')) {
    // Assume it's a domain if no @ symbol
    // Check both exact match and subdomain match
    return domainLower === ruleLower || domainLower.endsWith(`.${ruleLower}`);
  } else {
    // It's a full email address
    return emailLower === ruleLower;
  }
}

/**
 * Check for spam indicators
 */
function checkSpamIndicators(from, subject, body) {
  let spamScore = 0;
  const reasons = [];
  
  // Handle empty inputs
  if (!subject) subject = '';
  if (!body) body = '';
  if (!from) from = '';
  
  // Common spam patterns in subject
  const spamSubjectPatterns = [
    /\b(viagra|cialis|pharmacy|pills|medication)\b/i,
    /\b(winner|won|prize|lottery|million|thousand)\s*(dollar|usd|\$)/i,
    /\b(free|100%|guarantee|act now|limited time|urgent)\b/i,
    /\b(click here|unsubscribe|opt.?out|remove me)\b/i,
    /ðŸ’°|ðŸŽ°|ðŸ’Š|ðŸ’µ|ðŸ¤‘/,
    /\b(crypto|bitcoin|investment opportunity)\b/i,
    /\b(work from home|make money|earn cash)\b/i
  ];
  
  // Check subject for spam patterns
  for (const pattern of spamSubjectPatterns) {
    if (pattern.test(subject)) {
      spamScore += 30;
      reasons.push('spam subject pattern');
      break;
    }
  }
  
  // Check for excessive capitals (only if subject has content)
  if (subject.length > 10) {
    const capitalRatio = (subject.match(/[A-Z]/g) || []).length / subject.length;
    if (capitalRatio > 0.5) {
      spamScore += 20;
      reasons.push('excessive capitals');
    }
  }
  
  // Check for suspicious sender patterns
  const suspiciousSenderPatterns = [
    /no.?reply/i,
    /mailer.?daemon/i,
    /postmaster/i,
    /\d{5,}/  // Many numbers in email
  ];
  
  for (const pattern of suspiciousSenderPatterns) {
    if (pattern.test(from)) {
      spamScore += 15;
      reasons.push('suspicious sender');
      break;
    }
  }
  
  // Check body for spam content
  const spamBodyPatterns = [
    /\b(unsubscribe|stop receiving|opt.?out)\b/i,
    /\b(this is not spam|not junk mail)\b/i,
    /\b(risk.?free|money.?back|satisfaction guaranteed)\b/i
  ];
  
  const bodyLower = body.toLowerCase();
  for (const pattern of spamBodyPatterns) {
    if (pattern.test(bodyLower)) {
      spamScore += 10;
      reasons.push('spam body content');
      break;
    }
  }
  
  return {
    isSpam: spamScore >= 40,
    confidence: Math.min(spamScore, 100),
    reason: reasons.join(', ') || 'spam indicators'
  };
}

/**
 * Check for personal email indicators
 */
function checkPersonalIndicators(from, subject, body) {
  let personalScore = 0;
  const reasons = [];
  
  // Handle empty inputs
  if (!subject) subject = '';
  if (!body) body = '';
  if (!from) from = '';
  
  // Check for personal greeting patterns
  const personalGreetings = [
    /^(hi|hello|hey|dear)\s+\w+/i,
    /\b(thank you|thanks|appreciate)\b/i,
    /\b(looking forward|hope you|wondering if)\b/i
  ];
  
  const bodyLower = body.toLowerCase();
  for (const pattern of personalGreetings) {
    if (pattern.test(bodyLower)) {
      personalScore += 30;
      reasons.push('personal greeting');
      break;
    }
  }
  
  // Check for questions (indicates conversation)
  if (bodyLower.includes('?')) {
    personalScore += 20;
    reasons.push('contains questions');
  }
  
  // Check sender - personal emails usually from individual addresses
  const fromLower = from.toLowerCase();
  if (!fromLower.includes('noreply') && !fromLower.includes('no-reply') && 
      !fromLower.includes('newsletter') && !fromLower.includes('marketing')) {
    personalScore += 20;
    reasons.push('personal sender');
  }
  
  // Check subject length - personal emails tend to have shorter subjects
  if (subject.length < 100 && subject.length > 3) {
    personalScore += 15;
    reasons.push('appropriate subject length');
  }
  
  // Check for absence of marketing language
  const marketingPatterns = [
    /\b(sale|discount|offer|deal|save|buy now)\b/i,
    /\b(newsletter|update|announcement)\b/i,
    /\b(unsubscribe|preferences|email settings)\b/i
  ];
  
  let hasMarketing = false;
  for (const pattern of marketingPatterns) {
    if (pattern.test(bodyLower) || pattern.test(subject.toLowerCase())) {
      hasMarketing = true;
      break;
    }
  }
  
  if (!hasMarketing) {
    personalScore += 25;
    reasons.push('no marketing language');
  }
  
  return {
    isPersonal: personalScore >= 50,
    confidence: Math.min(personalScore, 100),
    reasons: reasons.join(', ')
  };
}

/**
 * Log filtered email to database
 */
export async function logFilteredEmail(customerId, gmailConnectionId, emailData, filterResult) {
  try {
    // Create the table if it doesn't exist
    await createFilterLogsTableIfNeeded();
    
    const logQuery = `
      INSERT INTO email_filter_logs (
        customer_id, gmail_connection_id, email_from, email_subject,
        filter_reason, filter_type, matched_rule, gmail_message_id, thread_id
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `;
    
    await query(logQuery, [
      customerId,
      gmailConnectionId || null,
      emailData.from || 'unknown',
      emailData.subject || 'No subject',
      filterResult.reason || 'unknown',
      filterResult.filterType || 'other',
      filterResult.matchedRule || null,
      emailData.messageId || null,
      emailData.threadId || null
    ]);
    
    console.log('ðŸ“ Logged filtered email');
  } catch (error) {
    console.error('Error logging filtered email:', error);
    // Don't throw - logging failure shouldn't break filtering
  }
}

/**
 * Create filter logs table if it doesn't exist
 */
async function createFilterLogsTableIfNeeded() {
  try {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS email_filter_logs (
        id SERIAL PRIMARY KEY,
        customer_id INTEGER REFERENCES customers(id),
        gmail_connection_id INTEGER,
        email_from VARCHAR(255) NOT NULL,
        email_subject VARCHAR(500),
        filter_reason VARCHAR(255) NOT NULL,
        filter_type VARCHAR(100) NOT NULL,
        matched_rule TEXT,
        filtered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        gmail_message_id VARCHAR(255),
        thread_id VARCHAR(255)
      )
    `;
    await query(createTableQuery);
  } catch (error) {
    // Table might already exist, that's fine
    if (!error.message.includes('already exists')) {
      console.error('Error creating filter logs table:', error);
    }
  }
}

/**
 * Get filter statistics for a customer
 */
export async function getFilterStatistics(customerId, days = 7) {
  try {
    const statsQuery = `
      SELECT 
        filter_type,
        COUNT(*) as count,
        COUNT(DISTINCT email_from) as unique_senders
      FROM email_filter_logs
      WHERE customer_id = $1
        AND filtered_at >= NOW() - INTERVAL '${days} days'
      GROUP BY filter_type
      ORDER BY count DESC
    `;
    
    const result = await query(statsQuery, [customerId]);
    
    return {
      totalFiltered: result.rows.reduce((sum, row) => sum + parseInt(row.count), 0),
      byType: result.rows.map(row => ({
        type: row.filter_type,
        count: parseInt(row.count),
        uniqueSenders: parseInt(row.unique_senders)
      }))
    };
  } catch (error) {
    console.error('Error getting filter statistics:', error);
    return { totalFiltered: 0, byType: [] };
  }
}
